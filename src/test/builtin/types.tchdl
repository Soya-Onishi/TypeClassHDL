package std::types

import std::traits:::HW

struct Int {}
struct Bit[m: Num] where m: min 1 {}
struct String {}
struct Unit {}
struct Num {}
struct Str {}
struct Bool {}
struct Vector[m: Num, T] where m: min 0, T: HW

impl[m: Num] Bit[m] where m: min 1 {
  @built_in[truncateBit: () => Bit]
  def truncate[x: Num, y: Num]() -> Bit[x - y + 1]
    where x: min 1 & max m - 1,
          y: min 1 & max x
  {
    this.truncate[x, y]()
  }

  @built_in[bitBit: () => Bit]
  def bit[x: Num]() -> Bit[1]
    where x: min 1 & max m - 1
  {
    this.bit[x]()
  }

  @built_in[concatBit: (Bit) => Bit]
  def concat[n: Num](that: Bit[n]) -> Bit[m + n]
    where n: min 1
  {
    this.concat[n](that)
  }
}

impl[m: Num, T] Vector[m, T]
  where m: min 0,
        T: HW
{
  @built_in[appendVec: (*) => Vector]
  def append(elem: T) -> Vector[m + 1, T] {
    this.append(elem)
  }
}

impl[m: Num, T] Vector[m, T]
  where m: min 1,
        T: HW
{
  @built_in[truncateVec: () => Vector]
  def truncate[hi: Num, lo: Num]() -> Vector[hi - lo + 1, T]
    where hi: max m - 1 & min 0,
          lo: max hi & min 0
  {
    this.truncate[hi, lo]()
  }

  def head() -> T {
    this.idx[0]()
  }

  def last() -> T {
    this.idx[m - 1]()
  }

  @built_in[idxVec: () => *]
  def idx[x: Num]() -> T
    where x: min 0 & max m - 1
  {
    this.idx[x]()
  }

  @built_in[idxDynVec: (Bit) => *]
  def idxDyn[n: Num](idx: Bit[n]) -> T
    where n: min 1
  {
    this.idxDyn[n](idx)
  }

  @built_in[updatedVec: (*) => Vector]
  def updated[idx: Num](elem: T) -> Vector[m, T]
    where idx: min 0 & max m - 1
  {
    this.updated[idx](elem)
  }

  @built_in[updatedDynVec: (Bit, *) => Vector]
  def updatedDyn[n: Num](idx: Bit[n], elem: T) -> Vector[m, T]
    where n: min 1
  {
    this.updatedDyn[n](idx, elem)
  }
}

impl[T] Vector[0, T]
  where T: HW
{
  @built_in[emptyVec: () => Vector]
  static def empty() -> Vector[0, T] {
    Vector[0, T]:::empty()
  }
}

impl[T] Vector[1, T]
  where T: HW
{
  static def new(head: T) -> Vector[1, T] {
    Vector[0, T]:::empty().append(head)
  }

  def tail() -> Vector[0, T] {
    Vector[0, T]:::empty()
  }

  def init() -> Vector[0, T] {
    Vector[0, T]:::empty()
  }
}

impl[m: Num, T] Vector[m, T]
  where T: HW,
        m: min 2
{
  def tail() -> Vector[m - 1, T] {
    this.truncate[m - 2, 0]()
  }

  def init() -> Vector[m - 1, T] {
    this.truncate[m - 1, 1]()
  }
}

module Memory[depth: Num, width: Num, T]
  where depth: min 1,
        width: min 1,
        T: HW

impl[depth: Num, width: Num, T] Memory[depth, width, T]
  where depth: min 1,
        width: min 1,
        T: HW
{
  @built_in[readMem: (Bit) => Future]
  input def read(addr: Bit[width]) -> Future[T] {
    this.reading(addr)
  }

  def reading(addr: Bit[width]) -> Future[T] {
    this.reading(addr)
  }

  @built_in[writeMem: (Bit, *) => Unit]
  input def write(addr: Bit[width], data: T) -> Unit {
    this.writing(addr, data)
  }

  def writing(addr: Bit[width], data: T) -> Unit {
    this.writing(addr, data)
  }
}


enum Future[T] where T: HW {
  Ready(T)
  NotReady
}

enum Ordering {
  Lt
  Eq
  Gt
}
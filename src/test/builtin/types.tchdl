package std::types

import std::traits:::HW

struct Int {}
struct Bit[m: Num] where m: min 1 {}
struct String {}
struct Unit {}
struct Num {}
struct Str {}
struct Bool {}
struct Vector[m: Num, T] where m: min 0, T: HW

impl[m: Num] Bit[m] where m: min 1 {
  @built_in[truncateBit: () => Bit]
  def truncate[x: Num, y: Num]() -> Bit[x - y + 1]
    where x: min 1 & max m - 1,
          y: min 1 & max x,
          x - y + 1:  min 1
  {
    this.truncate[x, y]()
  }

  @built_in[bitBit: () => Bit]
  def bit[x: Num]() -> Bit[1]
    where x: min 1 & max m - 1
  {
    this.bit[x]()
  }

  @built_in[concatBit: (Bit) => Bit]
  def concat[n: Num](that: Bit[n]) -> Bit[m + n]
    where n: min 1
  {
    this.concat[n](that)
  }
}

impl[m: Num, T] Vector[m, T]
  where m: min 0,
        T: HW
{
  @built_in[idxVec: () => *]
  def idx[x: Num]() -> T
    where x: min 0 & max m - 1
  {
    this.idx[x]()
  }

  @built_in[idxDynVec: (Bit) => *]
  def idxDyn[n: Num](idx: Bit[n]) -> T
    where n: min 1
  {
    this.idxDyn[n](idx)
  }

  @built_in[updatedVec: (*) => Vector]
  def updated[idx: Num](elem: T) -> Vector[m, T]
    where idx: min 0 & max m - 1
  {
    this.updated[idx](elem)
  }

  @built_in[updatedDynVec: (Bit, *) => Vector]
  def updatedDyn[n: Num](idx: Bit[n], elem: T) -> Vector[m, T]
    where n: min 1
  {
    this.updatedDyn[n](idx, elem)
  }
}

module Memory[depth: Num, width: Num, T]
  where depth: min 1,
        width: min 1,
        T: HW

impl[depth: Num, width: Num, T] Memory[depth, width, T]
  where depth: min 1,
        width: min 1,
        T: HW
{
  @built_in[readMem: (Bit) => Future]
  input def read(addr: Bit[width]) -> Future[T] {
    this.reading(addr)
  }

  def reading(addr: Bit[width]) -> Future[T] {
    this.reading(addr)
  }

  @built_in[writeMem: (Bit, *) => Unit]
  input def write(addr: Bit[width], data: T) -> Unit {
    this.writing(addr, data)
  }

  def writing(addr: Bit[width], data: T) -> Unit {
    this.writing(addr, data)
  }
}


enum Future[T] where T: HW {
  Ready(T)
  NotReady
}

enum Ordering {
  Lt
  Eq
  Gt
}